@using OcelotUI.Application.Interfaces
@inject IStringLocalizer<SharedResource> L
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject IOcelotConfigurationRepository Repository
@inject JsonPreviewState PreviewState
@implements IDisposable

<MudPaper Class="pa-3" Elevation="1" Style="height: 100%; display: flex; flex-direction: column; overflow: hidden; background: #1e1e1e; color: #fff;">
    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-2">
        <MudText Typo="Typo.subtitle1" Style="color: #fff;"><b>@L["JsonPreview_Title"]</b></MudText>
        <MudStack Row="true" Spacing="0">
            <MudIconButton Icon="@Icons.Material.Filled.Refresh"
                           Size="Size.Small"
                           Color="Color.Inherit"
                           OnClick="ReloadAsync"
                           title="@L["JsonPreview_Refresh"]" />
            <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                           Size="Size.Small"
                           Color="Color.Inherit"
                           OnClick="CopyToClipboard"
                           title="@L["JsonPreview_Copied"]" />
        </MudStack>
    </MudStack>
    <div style="flex: 1; min-height: 0; overflow: hidden;">
        <StandaloneCodeEditor @ref="_editor"
                              ConstructionOptions="EditorConstructionOptions"
                              OnDidInit="OnEditorInit" />
    </div>
</MudPaper>

@code {
    private string _json = "";
    private StandaloneCodeEditor _editor = null!;
    private bool _editorReady;
    private string[] _decorationIds = [];

    private static readonly System.Text.Json.JsonSerializerOptions JsonOptions = new()
    {
        WriteIndented = true,
        DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull,
        Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
    };

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            Language = "json",
            Theme = "vs-dark",
            Value = _json,
            ReadOnly = true,
            AutomaticLayout = true,
            Folding = true,
            LineNumbers = "on",
            Minimap = new EditorMinimapOptions { Enabled = false },
            ScrollBeyondLastLine = false,
            RenderLineHighlight = "none",
            FontSize = 13,
        };
    }

    protected override async Task OnInitializedAsync()
    {
        PreviewState.OnChange += OnConfigChanged;
        PreviewState.OnFocusChange += OnFocusChanged;
        var config = await Repository.LoadAsync();
        _json = System.Text.Json.JsonSerializer.Serialize(config, JsonOptions);
    }

    private async void OnConfigChanged()
    {
        await InvokeAsync(ReloadAsync);
        await InvokeAsync(StateHasChanged);
    }

    private async void OnFocusChanged()
    {
        if (!_editorReady)
            return;

        if (PreviewState.FocusSection is { } section)
        {
            await InvokeAsync(async () => await ScrollToSectionAsync(section, PreviewState.FocusIndex));
        }
        else
        {
            await InvokeAsync(ClearDecorationsAsync);
        }
    }

    private async Task OnEditorInit()
    {
        _editorReady = true;

        // Inject highlight CSS for all sections
        await JS.InvokeVoidAsync("eval", """
            if (!document.getElementById('preview-highlight-style')) {
                var s = document.createElement('style');
                s.id = 'preview-highlight-style';
                s.textContent = [
                    '.monaco-editor .route-highlight { background: rgba(255, 200, 50, 0.45) !important; border-left: 4px solid #ffc832 !important; }',
                    '.monaco-editor .global-highlight { background: rgba(50, 150, 255, 0.35) !important; border-left: 4px solid #3296ff !important; }',
                    '.monaco-editor .aggregate-highlight { background: rgba(50, 220, 100, 0.35) !important; border-left: 4px solid #32dc64 !important; }',
                    '.monaco-editor .dynamic-highlight { background: rgba(180, 100, 255, 0.35) !important; border-left: 4px solid #b464ff !important; }'
                ].join('\n');
                document.head.appendChild(s);
            }
        """);

        if (PreviewState.FocusSection is { } section)
        {
            await ScrollToSectionAsync(section, PreviewState.FocusIndex);
        }
    }

    private static (string ClassName, string RulerColor) GetHighlightStyle(PreviewSection section) => section switch
    {
        PreviewSection.Routes => ("route-highlight", "rgba(255, 200, 50, 0.5)"),
        PreviewSection.GlobalConfiguration => ("global-highlight", "rgba(50, 150, 255, 0.5)"),
        PreviewSection.Aggregates => ("aggregate-highlight", "rgba(50, 220, 100, 0.5)"),
        PreviewSection.DynamicRoutes => ("dynamic-highlight", "rgba(180, 100, 255, 0.5)"),
        _ => ("route-highlight", "rgba(255, 200, 50, 0.5)"),
    };

    private static string SectionJsonKey(PreviewSection section) => section switch
    {
        PreviewSection.Routes => "Routes",
        PreviewSection.GlobalConfiguration => "GlobalConfiguration",
        PreviewSection.Aggregates => "Aggregates",
        PreviewSection.DynamicRoutes => "DynamicRoutes",
        _ => "Routes",
    };

    private async Task ScrollToSectionAsync(PreviewSection section, int? index)
    {
        (int Start, int End)? range;

        if (section == PreviewSection.GlobalConfiguration)
        {
            range = FindObjectLineRange(_json, SectionJsonKey(section));
        }
        else
        {
            range = index.HasValue ? FindArrayItemLineRange(_json, SectionJsonKey(section), index.Value) : null;
        }

        if (range is not null)
        {
            var (className, rulerColor) = GetHighlightStyle(section);

            _decorationIds = await _editor.DeltaDecorations(_decorationIds,
            [
                new ModelDeltaDecoration
                {
                    Range = new BlazorMonaco.Range(range.Value.Start, 1, range.Value.End, 1),
                    Options = new ModelDecorationOptions
                    {
                        IsWholeLine = true,
                        ClassName = className,
                        OverviewRuler = new ModelDecorationOverviewRulerOptions
                        {
                            Color = rulerColor,
                            Position = OverviewRulerLane.Full,
                        },
                    },
                },
            ]);
            await _editor.RevealLineInCenter(range.Value.Start);
        }
    }

    private async Task ClearDecorationsAsync()
    {
        if (_decorationIds.Length > 0)
        {
            _decorationIds = await _editor.DeltaDecorations(_decorationIds, []);
        }
    }

    /// <summary>
    /// Find the line range of an array item (e.g. Routes[2], Aggregates[0]) in JSON text.
    /// </summary>
    private static (int Start, int End)? FindArrayItemLineRange(string json, string sectionName, int itemIndex)
    {
        var marker = $"\"{sectionName}\"";
        var sectionStart = json.IndexOf(marker, StringComparison.Ordinal);
        if (sectionStart < 0)
            return null;

        var bracketStart = json.IndexOf('[', sectionStart);
        if (bracketStart < 0)
            return null;

        var depth = 0;
        var itemCount = 0;
        var inString = false;
        var escape = false;
        var startOffset = -1;

        for (var i = bracketStart + 1; i < json.Length; i++)
        {
            var c = json[i];

            if (escape) { escape = false; continue; }
            if (c == '\\' && inString) { escape = true; continue; }
            if (c == '"') { inString = !inString; continue; }
            if (inString) continue;

            if (c == '{')
            {
                depth++;
                if (depth == 1)
                {
                    if (itemCount == itemIndex)
                        startOffset = i;
                    else if (itemCount > itemIndex)
                        break;
                    itemCount++;
                }
            }
            else if (c == '}')
            {
                depth--;
                if (depth == 0 && startOffset >= 0)
                    return (CharOffsetToLine(json, startOffset), CharOffsetToLine(json, i));
            }
            else if (c == ']' && depth == 0)
            {
                break;
            }
        }

        return null;
    }

    /// <summary>
    /// Find the line range of a top-level object property (e.g. "GlobalConfiguration": { ... }).
    /// </summary>
    private static (int Start, int End)? FindObjectLineRange(string json, string sectionName)
    {
        var marker = $"\"{sectionName}\"";
        var keyStart = json.IndexOf(marker, StringComparison.Ordinal);
        if (keyStart < 0)
            return null;

        // Find the opening '{' after the key
        var braceStart = json.IndexOf('{', keyStart + marker.Length);
        if (braceStart < 0)
            return null;

        var depth = 0;
        var inString = false;
        var escape = false;

        for (var i = braceStart; i < json.Length; i++)
        {
            var c = json[i];

            if (escape) { escape = false; continue; }
            if (c == '\\' && inString) { escape = true; continue; }
            if (c == '"') { inString = !inString; continue; }
            if (inString) continue;

            if (c == '{') depth++;
            else if (c == '}')
            {
                depth--;
                if (depth == 0)
                    return (CharOffsetToLine(json, braceStart), CharOffsetToLine(json, i));
            }
        }

        return null;
    }

    private static int CharOffsetToLine(string text, int offset)
    {
        var line = 1;
        for (var i = 0; i < offset; i++)
        {
            if (text[i] == '\n')
                line++;
        }
        return line;
    }

    private async Task ReloadAsync()
    {
        var config = await Repository.LoadAsync();
        _json = System.Text.Json.JsonSerializer.Serialize(config, JsonOptions);

        if (_editorReady)
        {
            await _editor.SetValue(_json);
            _decorationIds = [];
            if (PreviewState.FocusSection is { } section)
            {
                await ScrollToSectionAsync(section, PreviewState.FocusIndex);
            }
        }
    }

    private async Task CopyToClipboard()
    {
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", _json);
        Snackbar.Add(L["JsonPreview_Copied"], Severity.Success);
    }

    public void Dispose()
    {
        PreviewState.OnChange -= OnConfigChanged;
        PreviewState.OnFocusChange -= OnFocusChanged;
    }
}
