@using OcelotUI.Application.Interfaces
@inject IStringLocalizer<SharedResource> L
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject IOcelotConfigurationRepository Repository
@inject JsonPreviewState PreviewState
@implements IDisposable

<MudPaper Class="pa-3" Elevation="1" Style="height: 100%; display: flex; flex-direction: column; overflow: hidden; background: #1e1e1e; color: #fff;">
    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-2">
        <MudText Typo="Typo.subtitle1" Style="color: #fff;"><b>@L["JsonPreview_Title"]</b></MudText>
        <MudStack Row="true" Spacing="0">
            <MudIconButton Icon="@Icons.Material.Filled.Refresh"
                           Size="Size.Small"
                           Color="Color.Inherit"
                           OnClick="ReloadAsync"
                           title="@L["JsonPreview_Refresh"]" />
            <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                           Size="Size.Small"
                           Color="Color.Inherit"
                           OnClick="CopyToClipboard"
                           title="@L["JsonPreview_Copied"]" />
        </MudStack>
    </MudStack>
    <div style="flex: 1; min-height: 0; overflow: hidden;">
        <StandaloneCodeEditor @ref="_editor"
                              ConstructionOptions="EditorConstructionOptions"
                              OnDidInit="OnEditorInit" />
    </div>
</MudPaper>

@code {
    private string _json = "";
    private StandaloneCodeEditor _editor = null!;
    private bool _editorReady;
    private string[] _decorationIds = [];

    private static readonly System.Text.Json.JsonSerializerOptions JsonOptions = new()
    {
        WriteIndented = true,
        DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull,
        Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
    };

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            Language = "json",
            Theme = "vs-dark",
            Value = _json,
            ReadOnly = true,
            AutomaticLayout = true,
            Folding = true,
            LineNumbers = "on",
            Minimap = new EditorMinimapOptions { Enabled = false },
            ScrollBeyondLastLine = false,
            RenderLineHighlight = "none",
            FontSize = 13,
        };
    }

    protected override async Task OnInitializedAsync()
    {
        PreviewState.OnChange += OnConfigChanged;
        PreviewState.OnFocusChange += OnFocusChanged;
        var config = await Repository.LoadAsync();
        _json = System.Text.Json.JsonSerializer.Serialize(config, JsonOptions);
    }

    private async void OnConfigChanged()
    {
        await InvokeAsync(ReloadAsync);
        await InvokeAsync(StateHasChanged);
    }

    private async void OnFocusChanged()
    {
        if (!_editorReady)
            return;

        if (PreviewState.FocusRouteIndex is { } index)
        {
            await InvokeAsync(async () => await ScrollToRouteAsync(index));
        }
        else
        {
            await InvokeAsync(ClearDecorationsAsync);
        }
    }

    private async Task OnEditorInit()
    {
        _editorReady = true;

        // Inject highlight CSS into the page (Monaco doesn't pick up external CSS reliably)
        await JS.InvokeVoidAsync("eval", """
            if (!document.getElementById('route-highlight-style')) {
                var s = document.createElement('style');
                s.id = 'route-highlight-style';
                s.textContent = '.monaco-editor .route-highlight { background: rgba(255, 200, 50, 0.45) !important; border-left: 4px solid #ffc832 !important; }';
                document.head.appendChild(s);
            }
        """);

        if (PreviewState.FocusRouteIndex is { } index)
        {
            await ScrollToRouteAsync(index);
        }
    }

    private async Task ScrollToRouteAsync(int routeIndex)
    {
        var range = FindRouteLineRange(_json, routeIndex);
        if (range is not null)
        {
            // Clear previous decorations and add new highlight
            _decorationIds = await _editor.DeltaDecorations(_decorationIds,
            [
                new ModelDeltaDecoration
                {
                    Range = new BlazorMonaco.Range(range.Value.Start, 1, range.Value.End, 1),
                    Options = new ModelDecorationOptions
                    {
                        IsWholeLine = true,
                        ClassName = "route-highlight",
                        OverviewRuler = new ModelDecorationOverviewRulerOptions
                        {
                            Color = "rgba(255, 200, 50, 0.5)",
                            Position = OverviewRulerLane.Full,
                        },
                    },
                },
            ]);
            await _editor.RevealLineInCenter(range.Value.Start);
        }
    }

    private async Task ClearDecorationsAsync()
    {
        if (_decorationIds.Length > 0)
        {
            _decorationIds = await _editor.DeltaDecorations(_decorationIds, []);
        }
    }

    private static (int Start, int End)? FindRouteLineRange(string json, int routeIndex)
    {
        // Find the "Routes": [ marker
        var routesArrayStart = json.IndexOf("\"Routes\"", StringComparison.Ordinal);
        if (routesArrayStart < 0)
            return null;

        var bracketStart = json.IndexOf('[', routesArrayStart);
        if (bracketStart < 0)
            return null;

        // Walk from the bracket, counting top-level '{' at depth 1 (inside the array)
        var depth = 0;
        var routeCount = 0;
        var inString = false;
        var escape = false;
        var startOffset = -1;

        for (var i = bracketStart + 1; i < json.Length; i++)
        {
            var c = json[i];

            if (escape)
            {
                escape = false;
                continue;
            }

            if (c == '\\' && inString)
            {
                escape = true;
                continue;
            }

            if (c == '"')
            {
                inString = !inString;
                continue;
            }

            if (inString)
                continue;

            if (c == '{')
            {
                depth++;
                if (depth == 1)
                {
                    if (routeCount == routeIndex)
                    {
                        startOffset = i;
                    }
                    else if (routeCount > routeIndex)
                    {
                        break;
                    }
                    routeCount++;
                }
            }
            else if (c == '}')
            {
                depth--;
                if (depth == 0 && startOffset >= 0)
                {
                    return (CharOffsetToLine(json, startOffset), CharOffsetToLine(json, i));
                }
            }
            else if (c == ']' && depth == 0)
            {
                break;
            }
        }

        return null;
    }

    private static int CharOffsetToLine(string text, int offset)
    {
        var line = 1;
        for (var i = 0; i < offset; i++)
        {
            if (text[i] == '\n')
                line++;
        }
        return line;
    }

    private async Task ReloadAsync()
    {
        var config = await Repository.LoadAsync();
        _json = System.Text.Json.JsonSerializer.Serialize(config, JsonOptions);

        if (_editorReady)
        {
            await _editor.SetValue(_json);
            _decorationIds = [];
            if (PreviewState.FocusRouteIndex is { } index)
            {
                await ScrollToRouteAsync(index);
            }
        }
    }

    private async Task CopyToClipboard()
    {
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", _json);
        Snackbar.Add(L["JsonPreview_Copied"], Severity.Success);
    }

    public void Dispose()
    {
        PreviewState.OnChange -= OnConfigChanged;
        PreviewState.OnFocusChange -= OnFocusChanged;
    }
}
